pipeline {
    agent any
    
    parameters {
        choice(name: 'TF_ACTION', choices: ['plan', 'apply', 'destroy'], description: 'Select Terraform Action')
        choice(name: 'INSTANCE_TYPE', choices: ['t3.small', 't3.micro', 'm7i-flex.large'], description: 'Select EC2 Size')
        string(name: 'INSTANCE_NAME', defaultValue: 'Capstone', description: 'Name tag for the EC2 instance')
    }

    stages {
        stage('Initialize') {
            steps {
                script {
                    // Clean old state/plugins to prevent "Plugin did not respond" OOM errors
                    sh "rm -rf .terraform"
                    sh "terraform init"
                }
            }
        }

        stage('Terraform Execution') {
            steps {
                withCredentials([file(credentialsId: 'aws-credentials-file', variable: 'SECRET_FILE_PATH')]) {
                    script {
                        // Extract AWS keys from the secret file
                        def accessKey = sh(script: "grep aws_access_key_id ${SECRET_FILE_PATH} | cut -d' ' -f3", returnStdout: true).trim()
                        def secretKey = sh(script: "grep aws_secret_access_key ${SECRET_FILE_PATH} | cut -d' ' -f3", returnStdout: true).trim()

                        withEnv([
                            "AWS_ACCESS_KEY_ID=${accessKey}",
                            "AWS_SECRET_ACCESS_KEY=${secretKey}",
                            "AWS_DEFAULT_REGION=us-east-1",
                            "TF_LOG=ERROR" // Minimizes memory logging overhead
                        ]) {
                            def tfArgs = "-var='instance_type=${params.INSTANCE_TYPE}' -var='instance_name=${params.INSTANCE_NAME}'"
                            
                            if (params.TF_ACTION == 'plan') {
                                sh "terraform plan ${tfArgs}"
                            } else {
                                sh "terraform ${params.TF_ACTION} -auto-approve ${tfArgs}"
                            }
                        }
                    }
                }
            }
        }
        stage('Ansible Configuration') {
            steps {
                script {
                    // Retrieve the Public IP address generated by Terraform
                    def ec2Ip = sh(script: "terraform output -raw ec2_public_ip", returnStdout: true).trim()
        
                    // Bind the Jenkins SSH credential to a temporary path variable (SSH_KEY_PATH)
                    withCredentials([sshUserPrivateKey(credentialsId: 'ec2-ssh-key', keyFileVariable: 'SSH_KEY_PATH')]) {
                        
                        // Run the Ansible playbook using the temporary key file path
                        sh """
                        ansible-playbook -i ${ec2Ip}, setup-aiops.yml \
                        --user ubuntu \
                        --private-key ${SSH_KEY_PATH} \
                        --ssh-common-args='-o StrictHostKeyChecking=no'
                        """
                    }
                }
            }
        }
    }
}
